import sys,os
import argparse
import dbcan_profiler_function as dpf
from Bio import SeqIO

import pandas as pd
### input ## rundbcan overview.txt
import time
import dbcan_profiler_class as dpc
### positive data was generated by rundbcan out
### rundbcan result
#AE000520.1_142	GH57(12-349)	GH57(8)	GH57	3

### prodigal 
#AE000520.1	Prodigal_v2.6.3	CDS	169279	171138	116.7	-	0	ID=18_142;partial=00;start_type=ATG;rbs_motif=GGA/GAG/AGG;rbs_spacer=5-10bp;gc_cont=0.447;conf=100.00;score=117.98;cscore=110.15;sscore=7.84;rscore=0.91;uscore=1.64;tscore=4.00;

#filter gff
#AE004092.2	Prodigal_v2.6.3	CDS	12805	14784	320.1	+	0	ID=AE004092.2_13|HMMER=-|Hotpep=-|DIAMOND=AA1;partial=00;start_type=ATG;rbs_motif=None;rbs_spacer=None;gc_cont=0.377;conf=99.99;score=321.14;cscore=315.61;sscore=5.53;rscore=-1.19;uscore=1.47;tscore=4.21;
### may be need to adjusted in the feature

def Align(args):
    start_t = time.time()
    sys.stderr.write("[***]Checking input paramters!\n")
    dpf.check_args(args)
    sys.stderr.write("[***]Preparing output directory!\n")
    dpf.mk_dir(args)
    sys.stderr.write("[***]Start to trim reads!\n")
    dpf.trim_reads(args)
    totalreadnum = dpf.read_count(args)
    sys.stderr.write('Prepare Run Time(second): ' + str(time.time() - start_t)+"\n")
    if args.bowtie:
        dpf.Run_Bowtie(args)
        paffile1,paffile2 = dpf.To_paf(args)
    if args.diamond:
        dpf.Run_Diamond(args)
    if args.bwa:
        dpf.Run_Bwa(args)
    if args.minimap:
        dpf.Run_Minimap(args)


def Get_ID(attri):
    fields = attri.split(";")
    ID,hmmers,hotpep,diamond = fields[0].split("|")
    ID_order = ID.split("_")[-1]
    hmmers = hmmers[len("HMMER="):].split("+")
    hotpep = hotpep[len("Hotpep="):].split("+")
    diamond = diamond[len("DIAMOND="):].split("+")
    hmmers_cazy = dpf.Clear_CAZy(hmmers)
    hotpep_cazy = dpf.Clear_CAZy(hotpep)
    diamond_cazy = dpf.Clear_CAZy(diamond)
    CaZy = list((hmmers_cazy & hotpep_cazy)|(hotpep_cazy&diamond_cazy)|(diamond_cazy&hmmers_cazy))
    if "-" in CaZy:
        CaZy = CaZy.remove("-")

    return ID_order,CaZy

class NativeRegion(object):
    def __init__(self,genomeid,start,end):
        self.Genomeid = genomeid
        self.Start = start
        self.End   = end
        self.times = 0
        self.predict = "TN"
    def __str__(self):
        return "\t".join([str(getattr(self, value)) for value in ["Genomeid","Start","End","predict"]])


class GFFRecord(object):
    def __init__(self,lines):
        ### basic information 
        self.Genomeid = lines[0]
        self.Source = lines[1]
        self.Type  = lines[2]
        self.Start  = int(lines[3])
        self.End = int(lines[4])
        self.Score = lines[5]
        self.Strand = lines[6]
        self.Phase  = lines[7]
        
        ### deal information
        ID_order,CaZy = Get_ID(lines[-1])
        self.Protid = self.Genomeid + "_" + ID_order
        self.CAZy = CaZy

    def __str__(self):
        return "\t".join([str(getattr(self, value)) for value in ["Protid","Source","Type","Start","End","Score","Strand","Phase","predict"]])
    
    def __lt__(self,other): ### sorted by genome coordinate
        if self.Start < other.Start:
            return True
        else:
            return False

class GFF(object):
    def __init__(self,filename):
        self.records = [GFFRecord(line.split()) for line in open(filename)]
    def __iter__(self):
        return iter(self.records)
    def Generate_positive_data(self):
        #protid2gffrecord = Gff.Protid2gffrecord()
        ### TN: negative was predicted as negative
        ### TP: positive was predicted as positive
        ### FN: positive was predicted as negative
        ### FP: negative was predicted as positive
        for gff in self:
            if gff.CAZy:
                gff.predict = "FN"
            else:
                gff.predict = "TN"
        
        return self.Contig2record()
    
    def Protid2gffrecord(self):
        return {record.Protid:record for record in self}
    
    def Contig2record(self):
        tmpdict = {}
        for record in self:
            tmpdict.setdefault(record.Genomeid,[]).append(record)
        return tmpdict

## Gff for the positive data


def output(tmpdict):
    for contig in tmpdict:
        for record in tmpdict[contig]:
            print (record)

def Generate_Negative_data(Gff):
    contig2gffrecords = Gff.Contig2record()
    Negative_regions = {}
    ### before the sorted 
    #output(contig2gffrecords)
    for contigid in contig2gffrecords:
        contig2gffrecords[contigid] = sorted(contig2gffrecords[contigid])
        genes_sorted = contig2gffrecords[contigid]
        Negative_regions.setdefault(contigid,[]).append(NativeRegion(contigid,0,genes_sorted[0].Start)) ## first region

        for i in range(len(contig2gffrecords[contigid])-1):
            if genes_sorted[i].End < genes_sorted[i+1].Start:
                Negative_regions.setdefault(contigid,[]).append(NativeRegion(contigid,genes_sorted[i].End,genes_sorted[i+1].Start))
    return Negative_regions
    
    ### after sorted
    #output(contig2gffrecords)


###  for evalue 

## S0R16664931/1   150 0   149 -   AIW92130.1|CE4|GH153    701 206 255 48  50  255 AS:i:99 ZR:i:247    ZE:f:6.6e-2

def get_evalue(lines):
    return float(lines[-1].split(":")[-1])

class Paf_evalue(object):
    def __init__(self,filename,evalue):
        self.records = [dpc.PafRecord(line.split()) for line in open(filename) if get_evalue(line.split()) <= float(evalue)]
    def __iter__(self):
        return iter(self.records)
    ### get reads id
    def GetReadId(self):
        return [record.Qsn for record in self]
    ### get protein id
    def GetSeqId(self): 
        return [record.SeqID for record in self]
    ### get protein id: protein length dictory
    def GetSeqLen(self):
        return {record.SeqID:record.Tsl for record in self}
    ### get CAZy family id 2 protein id: one-many
    def CAZy2SeqID(self,CazySeqId):
        for record in self:
            for cazy in record.CAZys:
                CazySeqId.setdefault(cazy,[]).append(record.SeqID)
    ## get protein id 2 read is: one-many
    def SeqID2ReadID(self,aa):
        for record in self:
            aa.setdefault(record.SeqID,[]).append(record.Qsn)
    def ReadID2Record(self):
        return {record.Qsn:record for record in self}
    def Output(self):
        [print (record) for record in self]
    ## the CAZy information for megahit are not Qsn instead of they are in the 
    def Assign_CAZy_megahit(self):
        for cazy in self:
            cazy.CAZys = dpc.CAZy_filter(cazy.Qsn.strip("|").split("|")[1:])

### design for assemble free method to deal with the paf format file
### ### paf: https://github.com/lh3/miniasm/blob/master/PAF.md
### sam format file also convert to paf 
### https://bioconvert.readthedocs.io/en/master/developer_guide.html#how-to-update-bioconvert-on-bioconda
### diamond blastx: output format paf




def arg_parse():
    parser = argparse.ArgumentParser(description='dbCAN-profiler,ROC')
    parser.add_argument('-b', '--bowtie2', dest='bowtie', action='store_true', help='Run Bowtie2?', default=False)
    parser.add_argument('-m', '--minimap2', dest='minimap', action='store_true', help='Run minimap2?', default=False)
    parser.add_argument('-d', '--diamond', dest='diamond', action='store_true', help='Run diamond?', default=False)
    parser.add_argument('-a', '--bwa', dest='bwa', action='store_true', help='Run BWA?', default=False)
    parser.add_argument('-r1', dest='input1', type=str, help='R1 File' )
    parser.add_argument('-r2', dest='input2', type=str, help='R2 File' )
    parser.add_argument('-bi', dest='bowtieindex', type=str, help='Bowtie index for CAZy database (CDS).',  default=False)
    parser.add_argument('metric', help='Fscore.')
    parser.add_argument('-g',"--gff",help='new gff files with rundbcan result information.',type=str)
    parser.add_argument('-paf1',"--paf1",help='Paf filename for goldenstand(R1).',type=str)
    parser.add_argument('-paf',"--paf",help='Paf filename for megahit.',type=str)
    parser.add_argument('-paf2',"--paf2",help='Paf filename for goldenstand(R2).',type=str)
    parser.add_argument('-p1R1',"--p1R1",help='Paf filename for Pipeline (R1).',type=str)
    parser.add_argument('-p1R2',"--p1R2",help='Paf filename for Pipeline (R2).',type=str)
    parser.add_argument('-ab',"--abundance",help='Abundance.',type=str)
    parser.add_argument('-st',"--sampletable",help='Sample table.',type=str)
    parser.add_argument('-gg',"--goldengenome",help='Goldenstandard genome.',type=str)
    parser.add_argument('-o', dest='output', type=str, help='Output location?', default="dbcan-profiler/")
    parser.add_argument('-tr',"--trim_core",help='core number for trim reads! default:12 ',default="12",type=str)
    parser.add_argument('-bc',"--bowtie_core",help='core number for bowtie2 alignment! default:32 ',default="32",type=str)
    parser.add_argument('-gt',"--gold_genome_type",help='Golden standard genome type. mouse or human.',type=str)
    parser.add_argument('-l',"--label",help='label for output',type=str)
    parser.add_argument('-lineage',"--lineage",help='label for output',type=str)
    parser.add_argument('-fscore',"--fscore",help='label for output',type=str)
    parser.add_argument('-seqlen',"--seqlen",help='label for output',type=str)
    parser.add_argument('-evalue',"--evalue",help='Evalue for filter diamond result.',type=str)
    parser.add_argument('-out',"--out",default="out.csv",type=str)
    return parser.parse_args()

## gff
#CP003040.1	Prodigal_v2.6.3	CDS	2369413	2370552	126.3	-	0	ID=CP003040.1_2107|HMMER=GH53(13-370)|Hotpep=GH53(3)+CBM61(1)|DIAMOND=GH53;partial=00;start_type=ATG;rbs_motif=GGA/GAG/AGG;rbs_spacer=5-10bp;gc_cont=0.516;conf=100.00;score=127.23;cscore=118.78;sscore=8.45;rscore=-2.06;uscore=6.85;tscore=2.70;

## reads were mapped to golden genome
#S0R19/1	149	0	149	-	CP003040.1_2107|GH53	1140	355	504	144	149	42	AS:i:-10	XN:i:0	XM:i:5	XO:i:0	XG:i:0	NM:i:5	MD:Z:1G23T57G9G12C42	YT:Z:UU	cg:Z:149M
## reads were mapped to CAZy
#S0R19/1	149	0	149	-	AEN97298.1|GH53	1113	328	477	144	149	42	AS:i:-10	XN:i:0	XM:i:5	XO:i:0	XG:i:0	NM:i:5	MD:Z:1G23T57G9G12C42	YT:Z:UU	cg:Z:149M

## CAZy in gff files and paf for golden are the same. So, from paf file, we can get the position information. 
## reads mapped to CAZy is the prediciton of the read.



### map to genome, get the coordinate information, connect the prediction to golden results
#S0R0/1	150	0	150	+	CP003040.1	3592125	65078	65228	147	150	42	AS:i:-6	XN:i:0	XM:i:3	XO:i:0	XG:i:0	NM:i:3	MD:Z:107T6G28C6	YT:Z:UU	cg:Z:150M
#S0R19/1	149	0	149	+	CP003040.1	3592125	2370048	2370197	144	149	42	AS:i:-10	XN:i:0	XM:i:5	XO:i:0	XG:i:0	NM:i:5	MD:Z:42G12C9C57A23C1	YT:Z:UU	cg:Z:149M
### map to CAZy, get the prediction result
#S0R19/1	149	0	149	-	AEN97298.1|GH53	1113	328	477	144	149	42	AS:i:-10	XN:i:0	XM:i:5	XO:i:0	XG:i:0	NM:i:5	MD:Z:1G23T57G9G12C42	YT:Z:UU	cg:Z:149M

## So, we need to get the coordinates of prediction by combining the two paf


def GetCAZy(CAZypaf,Read2coorsR):
    for record in CAZypaf:
        try:
            record.Strand = Read2coorsR[record.Qsn].Strand
            record.Ts = Read2coorsR[record.Qsn].Ts
            record.Te = Read2coorsR[record.Qsn].Te
            record.SeqID = Read2coorsR[record.Qsn].Tsn
        except:
            pass

def PositivePredict(CAZypaf,Positive):
    for cazy in CAZypaf:
        Genomeid = cazy.SeqID ### may some
        if Genomeid not in Positive:
            sys.stderr.write(f"{Genomeid}:{cazy.Qsn} not in Positive data!\n")
        else:
            ### loop for 
            for record in Positive[Genomeid]:
                if record.Start <= int(cazy.Ts) <= record.End or record.Start <= int(cazy.Te) <= record.End:
                    #print (cazy,record)
                    #print (record.CAZy,cazy.CAZys)
                    if set(record.CAZy) & cazy.CAZys:
                        record.predict = "TP" ##
                        break
                    if not record.CAZy and cazy.CAZys: ###
                        record.predict = "FP" ### TN was predicted as posivtive 
                        break

def NegativePredict(CAZypaf,Negative):
    for cazy in CAZypaf:
        #print (cazy);exit()
        Genomeid = cazy.SeqID ### may some
        if Genomeid not in Negative:
            sys.stderr.write(f"{Genomeid}:{cazy.Qsn} not in Negative data!\n")
        else:
            ### loop for 
            for record in Negative[Genomeid]:### Negative region
                if record.Start <= int(cazy.Ts) <= record.End and record.Start <= int(cazy.Te) <= record.End:
                    #print(cazy);print(record)
                    record.predict = "FP" ## negative was predicted as positive
                    break

def Summary(Positive,Negative):
    TP,TN,FP,FN = 0.,0.,0.,0.
    for genomeid in Positive:
        for record in Positive[genomeid]:
            if record.predict == "TP":
                TP += 1
            elif record.predict == "FN":
                FN += 1
            elif record.predict == "TN":
                TN += 1
            else:
                FP += 1
    for genomeid in Negative:
        for record in Negative[genomeid]:
            if record.predict == "TP":
                TP += 1
            elif record.predict == "FN":
                FN += 1
            elif record.predict == "TN":
                TN += 1
            else:
                FP += 1
    print(f"TP,TN,FP,FN")
    print(f"{TP},{TN},{FP},{FN}")
    #1.0 149055.0 0.0 70136.0
    Acc=(TP+TN)/(TP+TN+FP+FN)
    Sen=TP/(TP+FN)
    Pre=TP/(TP+FP)
    Rec=TP/(TP+FN)
    F1 = 2*Pre*Rec/(Pre+Rec)
    TPR = TP/(TP+FN)
    FPR = FP/(FP+TN)
    print (f"Acc,Sen,Pre,Rec,F1,TPR,FPR")
    print (f"{Acc},{Sen},{Pre},{Rec},{F1},{TPR},{FPR}")

def Fscore(args):
    Gff = GFF(args.gff)
    Positive = Gff.Generate_positive_data() ## generated positive data, only need gff
    Negative = Generate_Negative_data(Gff) ## generated negative data, only need gff
    Genomepaf1 = dpc.Paf(args.paf1)  ## read map to genome
    Genomepaf2 = dpc.Paf(args.paf2)  ## 
    CAZypaf1   = dpc.Paf(args.p1R1)  ### read map to CAZy
    CAZypaf2   = dpc.Paf(args.p1R2)
    Read2coorsR1 = Genomepaf1.ReadID2Record() ### help to combined CAZy and genome coordinate
    Read2coorsR2 = Genomepaf2.ReadID2Record()
    GetCAZy(CAZypaf1,Read2coorsR1) ### combine CAZy and genome coordinates
    GetCAZy(CAZypaf2,Read2coorsR2) ### CAZy and genome coordinate
    PositivePredict(CAZypaf1,Positive) ### predict positive 
    PositivePredict(CAZypaf2,Positive) ### predict positive
    NegativePredict(CAZypaf1,Negative) ### predict negative 
    NegativePredict(CAZypaf2,Negative) #### predict negetive
    Summary(Positive,Negative)
    #CAZypaf1.Output()
    #output(Positive)
    #output(Negative)
    #for gff in Gff:
    #    print (gff)
    #

def P2Fscore(args):
    Gff = GFF(args.gff)
    Positive = Gff.Generate_positive_data() ## generated positive data, only need gff
    Negative = Generate_Negative_data(Gff) ## generated negative data, only need gff
    CAZy2genome = dpc.Paf(args.paf)
    CAZy2genome.Assign_CAZy_megahit()
    PositivePredict(CAZy2genome,Positive) ### predict positive 
    NegativePredict(CAZy2genome,Negative) ### predict negative 
    Summary(Positive,Negative)

def Get_sum_len(filename):
    command = 'seqkit stats ' + filename
    r = os.popen(command)
    info = r.readlines()
    count = 0
    for line in info:
        line = line.strip('\n')
        count += 1
        if count == 2:
            lines = line.split()
            sum_len = int(lines[4].replace(",",""))
            return sum_len

def Genome_coverage(args):
    sampletable =  dpf.Golden_smaple(args.sampletable).OTUdict()
    abundance = dpf.Read_abundance(args.abundance)
    expressedseqid = dpf.expression_seqid(abundance,sampletable)
    seqids = [record.seqid for record in expressedseqid]
    seqlens_dict = {line.split()[0]:float(line.split()[1]) for line in open(args.seqlen)}
    seqs_length = 0.
    #for record in SeqIO.parse(args.goldengenome,'fasta'):
    #    if record.id in seqids:
    #        seqs_length += len(record.seq)
    ## count reads
    for seqid in seqids:
        seqs_length += seqlens_dict[seqid]

    #print (f"Finished genome length: {seqs_length}")
    R1_len = Get_sum_len(args.input1)
    R2_len = Get_sum_len(args.input2)
    print("Sequencing Coverage: ",(R1_len+R2_len)/seqs_length)

def genome_ID2NCBI_ID(filename):
    return {line.split()[0]:line.split()[2] for line in open(filename) if line.split()[0] != "genome_ID"}

def taxonomic_profile(args):
    #sampletable =  dpf.Golden_smaple(args.sampletable).OTUdict()
    abundance = dpf.Read_abundance(args.abundance)
    if args.gold_genome_type == "human":
        genome2NCBI_ID = genome_ID2NCBI_ID("/mnt/array2/jinfang/CAMISIM_data/HMP/short_read/metadata.tsv")
    elif args.gold_genome_type == "mouse":
        genome2NCBI_ID = genome_ID2NCBI_ID("/mnt/ssd/jinfang/ECAMI_mice_gut/19122017_mousegut_scaffolds/metadata.tsv")
    elif args.gold_genome_type == "previous":
        genome2NCBI_ID = genome_ID2NCBI_ID("/mnt/array2/jinfang/BioSofts/CAMISIM/defaults/metadata.tsv")

    with open(f"{args.label}"+".Taxid",'w') as f:
        for genome in abundance:
            f.write(genome2NCBI_ID[genome]+"\n")
    dpf.check_return(os.system("perfect.7levels.sh "+f"{args.label}"+".Taxid > " + f"{args.label}.Taxonomy" ))


def filter_genome(args):
    sampletable =  dpf.Golden_smaple(args.sampletable).OTUdict()
    abundance = dpf.Read_abundance(args.abundance)
    expressedseqid = dpf.expression_seqid(abundance,sampletable)
    seqids = [record.seqid for record in expressedseqid]
    seqs = []
    for record in SeqIO.parse(args.goldengenome,'fasta'):
        if record.id in seqids:
            seqs.append(record)
    path,outname = os.path.split(args.goldengenome)
    SeqIO.write(seqs,outname+'.filter','fasta')

def filter_gff(args):
    sampletable =  dpf.Golden_smaple(args.sampletable).OTUdict()
    abundance = dpf.Read_abundance(args.abundance)
    expressedseqid = dpf.expression_seqid(abundance,sampletable)
    seqids = [record.seqid for record in expressedseqid]
    path,outname = os.path.split(args.gff.strip(".gff")+".filter.gff")
    with open(outname,'w') as f:
        for line in open(args.gff):
            lines = line.split()
            if lines[0] in seqids:
                f.write(line)


def paf_compare_with_evalue(args):
    start_t = time.time()
    sys.stderr.write("[***]Checking input paramters!\n")
    dpf.check_args(args)
    sys.stderr.write("[***]Preparing output directory!\n")
    dpf.mk_dir(args)
    sys.stderr.write("[***]Start to trim reads!\n")
    dpf.trim_reads(args)
    totalreadnum = dpf.read_count(args)
    #totalreadnum = dpf.get_count_reads_fq(args.input1)
    
    sys.stderr.write('Prepare Run Time(second): ' + str(time.time() - start_t)+"\n")
    paf1 = Paf_evalue(args.paf1,args.evalue)
    paf2 = Paf_evalue(args.paf2,args.evalue)
    cazyfpkm,readtable,cazy2seqid = dpf.Cal_FPKM(paf1,paf2,totalreadnum)
    dpf.FPKMToCsv(args,"Diamond."+args.evalue,cazyfpkm,readtable,cazy2seqid)

def Summary_each_genome(Positive,Negative):
    genomeids = Positive.keys()
    with open("Fscore.txt",'w') as f: 
        for genomeid in genomeids:
            TP,TN,FP,FN = 0.000000,0.000001,0.00001,0.000001
            for record in Positive[genomeid]:
                if record.predict == "TP":
                    TP += 1
                elif record.predict == "FN":
                    FN += 1
                elif record.predict == "TN":
                    TN += 1
                else:
                    FP += 1
            for record in Negative[genomeid]:
                if record.predict == "TP":
                    TP += 1
                elif record.predict == "FN":
                    FN += 1
                elif record.predict == "TN":
                    TN += 1
                else:
                    FP += 1
            #1.0 149055.0 0.0 70136.0
            try:
                Acc=(TP+TN)/(TP+TN+FP+FN)
                Sen=TP/(TP+FN)
                Pre=TP/(TP+FP)
                Rec=TP/(TP+FN)
                F1 = 2*Pre*Rec/(Pre+Rec)
                TPR = TP/(TP+FN)
                FPR = FP/(FP+TN)
                f.write(f"Genomeid,TP,TN,FP,FN,Acc,Sen,Pre,Rec,F1,TPR,FPR\n")
                f.write(f"{genomeid},{TP},{TN},{FP},{FN},{Acc},{Sen},{Pre},{Rec},{F1},{TPR},{FPR}\n")
            except:
                pass

def P1Fscore_genome(args):
    Gff = GFF(args.gff)
    Positive = Gff.Generate_positive_data() ## generated positive data, only need gff
    Negative = Generate_Negative_data(Gff) ## generated negative data, only need gff
    Genomepaf1 = dpc.Paf(args.paf1)  ## read map to genome
    Genomepaf2 = dpc.Paf(args.paf2)  ## 
    CAZypaf1   = dpc.Paf(args.p1R1)  ### read map to CAZy
    CAZypaf2   = dpc.Paf(args.p1R2)
    Read2coorsR1 = Genomepaf1.ReadID2Record() ### help to combined CAZy and genome coordinate
    Read2coorsR2 = Genomepaf2.ReadID2Record()
    GetCAZy(CAZypaf1,Read2coorsR1) ### combine CAZy and genome coordinates
    GetCAZy(CAZypaf2,Read2coorsR2) ### CAZy and genome coordinate
    PositivePredict(CAZypaf1,Positive) ### predict positive 
    PositivePredict(CAZypaf2,Positive) ### predict positive
    NegativePredict(CAZypaf1,Negative) ### predict negative 
    NegativePredict(CAZypaf2,Negative) #### predict negetive
    Summary_each_genome(Positive,Negative)

def genomeid2tax(args):
    #abundance = dpf.Read_abundance(args.abundance)
    if args.gold_genome_type == "human":
        genome2NCBI_ID = genome_ID2NCBI_ID("/mnt/array2/jinfang/CAMISIM_data/HMP/short_read/metadata.tsv")
    sampletable =  dpf.Golden_smaple(args.sampletable).OTUdict()
    taxids = [];seqid2info = {}
    for otuid in genome2NCBI_ID:
        for seqid in sampletable[otuid]:
            #print (otuid,genome2NCBI_ID[otuid],seqid)
            seqid2info[seqid] = (otuid,genome2NCBI_ID[otuid])
            if genome2NCBI_ID[otuid] not in taxids:
                taxids.append(genome2NCBI_ID[otuid])
    
    with open("taxid.txt","w") as f:
        f.write("\n".join(taxids))
    #os.system("perfect.7levels.sh taxid.txt > taxid.tax")
    #with open("seqid2taxid.csv","w") as f:
        
    taxonomy = dpc.Taxnomony("taxid.tax")
    taxid2lineage = taxonomy.taxid2tttt()
    print ("Genomeid,otuid,taxid,k,p,c,o,f,g,s")
    for seqid in seqid2info:
        taxid = str(seqid2info[seqid][1])
        str1 = str(taxid2lineage[taxid])
        str2 = str(seqid2info[seqid][0])
        seqid = str(seqid.seqid)
        print(seqid+","+str2+","+str1)


def relative_abund(args):
    #-ab /mnt/array2/jinfang/CAMISIM_data/HMP/short_read/abundance0.tsv
    abundance = dpc.Abundance(args.abundance)
    #print (abundance)
    total_abund = sum([float(record.abund) for record in abundance])
    print ("otuid,relative_abund")
    for record in abundance:
        print (record.genomeid +","+ str(float(record.abund)/total_abund))

def FscoreAndLineage(args):
    Fscore = pd.read_csv(args.fscore) 
    lineage  = pd.read_csv(args.lineage) 
    data = Fscore.merge(lineage,on=["Genomeid"])
    data.to_csv(args.out)

if __name__ == "__main__":
    args = arg_parse()
    if args.metric == "P1Fscore":
        # python3 ../extra_function.py P1Fscore -g new.filter.gff -paf1 test.R1.paf -paf2 test.R2.paf -p1R1 P1.bowtie.R1.paf -p1R2 P1.bowtie.R2.paf
        Fscore(args)
    if args.metric == "filter":
        filter_genome(args)
        ### step 1.1 filter genome based on abundance
        #python3 ../extra_function.py filter -ab /mnt/array2/jinfang/CAMISIM_data/HMP/short_read/abundance0.tsv -gg ../../HMP.goldstandard.genome.fasta -st /mnt/array2/jinfang/CAMISIM_data/HMP/short_read/mapping.table
    if args.metric == "Align":
        ### step 2 align reads to genome
        ### #python3 ../extra_function.py Align -b -r1 -r2 -bi
        Align(args)
    if args.metric == "filter_gff":
        ### step 1.2 filter gff files based on abundance
        #python3 ../extra_function.py filter_gff -ab /mnt/array2/jinfang/CAMISIM_data/HMP/short_read/abundance0.tsv -g new.gff -st /mnt/array2/jinfang/CAMISIM_data/HMP/short_read/mapping.table
        filter_gff(args)
    if args.metric == "P2Fscore":
        # python3 ../extra_function.py P2Fscore -g new.filter.gff -paf megahit.cds.paf
        P2Fscore(args)
    if args.metric == "coverage":
        # python3 ../extra_function.py coverage -ab /mnt/array2/jinfang/CAMISIM_data/HMP/short_read/abundance0.tsv -st /mnt/array2/jinfang/CAMISIM_data/HMP/short_read/mapping.table -r1 -r2
        Genome_coverage(args)
    if args.metric == "taxonomic_profile":
        # python3 ../extra_function.py taxonomic_profile -ab /mnt/array2/jinfang/CAMISIM_data/HMP/short_read/abundance0.tsv -gt human 
        # python3 ../extra_function.py taxonomic_profile -ab /mnt/array2/jinfang/dbcan_da/grant_test/out100M/distributions/distribution_0.txt -gt previous
        taxonomic_profile(args)
    if args.metric == "paf_compare_with_evalue":
        paf_compare_with_evalue(args)
    if args.metric == "P1Fscore_genome":
        ## python3 ../extra_function.py P1Fscore -g new.filter.gff -paf1 test.R1.paf -paf2 test.R2.paf -p1R1 P1.bowtie.R1.paf -p1R2 P1.bowtie.R2.paf
        P1Fscore_genome(args)
    if args.metric == "relative_abund":
        ### python3 extra_function.py relative_abund -ab /mnt/array2/jinfang/CAMISIM_data/HMP/short_read/abundance0.tsv 
        relative_abund(args)
    if args.metric == "genomeid2tax":
        #python3 extra_function.py genomeid2tax -st /mnt/array2/jinfang/CAMISIM_data/HMP/short_read/mapping.table -gt human
        genomeid2tax(args)
    if args.metric == "FscoreAndLineage":
        #python3 extra_function.py FscoreAndLineage -lineage seqid2lineage.csv -fscore Fscore.txt
        FscoreAndLineage(args)
